
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>PrettySheet</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.75.0/build/stlite.css" />
    <style>
        /* Opcional: Ocultar el men√∫ de Streamlit para que parezca una app nativa */
        #MainMenu {visibility: hidden;}
        footer {visibility: hidden;}
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.75.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl"],
        files: {"app.py": "import streamlit as st\nimport pandas as pd\nfrom io import BytesIO\n\n# Importaci\u00f3n del motor de procesamiento\ntry:\n    from core.formatter_pipeline import ExcelPipeline \nexcept ImportError:\n    ExcelPipeline = None\n\n# --- CONFIGURACI\u00d3N DE P\u00c1GINA ---\nst.set_page_config(\n    page_title=\"PrettySheet | Profesionales en Excel\",\n    page_icon=\"\ud83c\udfa8\",\n    layout=\"wide\"\n)\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.header(\"\u2699\ufe0f Configuraci\u00f3n Global\")\n    apply_styles = st.checkbox(\"Aplicar Estilos\", value=True)\n    adjust_widths = st.checkbox(\"Ajustar Anchos\", value=True)\n    \n    st.divider()\n    st.markdown(\"### \ud83c\udfa8 Colores Predeterminados\")\n    default_bg = st.color_picker(\"Fondo de cabecera base\", \"#1F4E78\")\n    default_txt = st.color_picker(\"Texto de cabecera base\", \"#FFFFFF\")\n    \n    st.divider()\n    st.info(\"\ud83d\ude80 **Local-First**: Tus datos se procesan en tu navegador y nunca viajan a un servidor.\")\n\n# --- CUERPO PRINCIPAL ---\nst.title(\"\ud83c\udfa8 PrettySheet\")\nst.caption(\"Ajusta el orden y los colores de cada columna de forma independiente.\")\n\nuploaded_file = st.file_uploader(\"Carga tu archivo Excel (.xlsx)\", type=\"xlsx\")\n\nif uploaded_file:\n    # 1. GESTI\u00d3N DE ESTADO: Cargar datos iniciales\n    if 'column_data' not in st.session_state or st.session_state.get('current_file') != uploaded_file.name:\n        file_bytes = BytesIO(uploaded_file.getvalue())\n        df_headers = pd.read_excel(file_bytes, nrows=0)\n        \n        # Inicializamos el estado con los colores base del sidebar\n        st.session_state.column_data = [\n            {\"name\": col, \"bg\": default_bg, \"txt\": default_txt} for col in df_headers.columns\n        ]\n        st.session_state.current_file = uploaded_file.name\n\n    # --- PANEL DE PERSONALIZACI\u00d3N ---\n    st.subheader(\"\ud83d\udee0\ufe0f Configuraci\u00f3n de Columnas\")\n    st.write(\"Cambia el orden con \u2b06\ufe0f \u2b07\ufe0f y elige colores espec\u00edficos para cada encabezado.\")\n\n    # Encabezados de la tabla de configuraci\u00f3n\n    h1, h2, h3, h4 = st.columns([1, 4, 1.5, 1.5])\n    with h1: st.write(\"**Orden**\")\n    with h2: st.write(\"**Columna (Vista Previa)**\")\n    with h3: st.write(\"**Fondo**\")\n    with h4: st.write(\"**Texto**\")\n    st.divider()\n\n    # 2. RENDERIZADO DE FILAS DIN\u00c1MICAS\n    for i, col_info in enumerate(st.session_state.column_data):\n        with st.container():\n            c1, c2, c3, c4 = st.columns([1, 4, 1.5, 1.5])\n            \n            with c1:\n                # Controles de movimiento\n                up = st.button(\"\u2b06\ufe0f\", key=f\"up_{i}\", disabled=(i == 0))\n                down = st.button(\"\u2b07\ufe0f\", key=f\"down_{i}\", disabled=(i == len(st.session_state.column_data)-1))\n                \n                if up:\n                    st.session_state.column_data[i], st.session_state.column_data[i-1] = \\\n                        st.session_state.column_data[i-1], st.session_state.column_data[i]\n                    st.rerun()\n                if down:\n                    st.session_state.column_data[i], st.session_state.column_data[i+1] = \\\n                        st.session_state.column_data[i+1], st.session_state.column_data[i]\n                    st.rerun()\n\n            with c2:\n                # Vista previa alineada\n                st.markdown(f\"\"\"\n                    <div style=\"\n                        background-color: {col_info['bg']}; \n                        color: {col_info['txt']}; \n                        padding: 10px; \n                        border-radius: 6px; \n                        text-align: center;\n                        font-weight: bold;\n                        border: 1px solid #ddd;\n                        font-family: sans-serif;\n                        font-size: 14px;\n                    \">\n                        {col_info['name']}\n                    </div>\n                \"\"\", unsafe_allow_html=True)\n            \n            with c3:\n                # Selector de fondo (sin texto de etiqueta para mayor limpieza)\n                col_info['bg'] = st.color_picker(\n                    f\"BG_{i}\", col_info['bg'], key=f\"picker_bg_{i}\", label_visibility=\"collapsed\"\n                )\n            \n            with c4:\n                # Selector de fuente\n                col_info['txt'] = st.color_picker(\n                    f\"TXT_{i}\", col_info['txt'], key=f\"picker_txt_{i}\", label_visibility=\"collapsed\"\n                )\n        st.write(\"\") # Espaciado entre filas\n\n    # --- ACCI\u00d3N FINAL ---\n    st.divider()\n    \n    if ExcelPipeline:\n        if st.button(\"\ud83d\ude80 Procesar y Generar Excel\", type=\"primary\", use_container_width=True):\n            with st.spinner(\"Generando formato profesional...\"):\n                file_bytes = BytesIO(uploaded_file.getvalue())\n                \n                # Preparar datos para el Pipeline\n                final_order = [c['name'] for c in st.session_state.column_data]\n                final_configs = {\n                    c['name']: {\n                        \"bg_color\": c['bg'].replace(\"#\", \"\"),\n                        \"txt_color\": c['txt'].replace(\"#\", \"\")\n                    } for c in st.session_state.column_data\n                }\n\n                pipeline = ExcelPipeline(\n                    column_order=final_order,\n                    column_configs=final_configs\n                )\n                \n                result_buffer = pipeline.process(file_bytes)\n                result_buffer.seek(0)\n                \n                # Mostrar \u00e9xito y descarga\n                st.success(\"\u00a1Archivo procesado con \u00e9xito!\")\n                \n                col_d1, col_d2 = st.columns(2)\n                with col_d1:\n                    df_preview = pd.read_excel(result_buffer)\n                    st.write(\"\ud83d\udcca Vista previa r\u00e1pida:\")\n                    st.dataframe(df_preview.head(5), use_container_width=True)\n                \n                with col_d2:\n                    st.write(\"\ud83d\udcbe Guardar resultado:\")\n                    result_buffer.seek(0)\n                    st.download_button(\n                        label=\"\ud83d\udce5 Descargar Excel Formateado\",\n                        data=result_buffer.getvalue(),\n                        file_name=f\"Pretty_{uploaded_file.name}\",\n                        mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                        use_container_width=True\n                    )\n    else:\n        st.error(\"\u26a0\ufe0f Error: No se pudo cargar el motor `ExcelPipeline`. Revisa la carpeta `core`.\")\n\nelse:\n    # Pantalla de bienvenida\n    st.info(\"\ud83d\udc4b \u00a1Bienvenido! Por favor, carga un archivo Excel arriba para comenzar a personalizarlo.\")\n    \n    # Ejemplo visual de qu\u00e9 hace la app\n    st.image(\"https://img.icons8.com/clouds/200/microsoft-excel.png\", width=100)\n    st.write(\"Con PrettySheet puedes:\")\n    st.write(\"- \u2195\ufe0f Reordenar columnas sin tocar el Excel original.\")\n    st.write(\"- \ud83c\udfa8 Asignar colores corporativos a cada encabezado.\")\n    st.write(\"- \ud83d\udccf Ajustar anchos de celda autom\u00e1ticamente.\")", "core/formatter_pipeline.py": "from io import BytesIO\nfrom core.column_reorderer import ColumnReorderer\nfrom core.stylizer import Stylizer\nfrom core.width_adjuster import WidthAdjuster\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nclass ExcelPipeline:\n    def __init__(self, column_order=None, column_configs=None, font_color=\"FFFFFF\"):\n        self.column_order = column_order\n        self.column_configs = column_configs or {} # Diccionario {col_name: {bg_color: ...}}\n        self.font_color = font_color\n\n    def process(self, input_buffer: BytesIO) -> BytesIO:\n        buf = input_buffer\n        \n        # 1. Reordenar primero es vital para que el Stylizer encuentre las celdas\n        if self.column_order:\n            buf = ColumnReorderer.reorder_columns(buf, self.column_order)\n        \n        # 2. Estilizar con el diccionario de configuraciones\n        buf = Stylizer.style_excel(buf, self.column_configs, self.font_color)\n        \n        # 3. Ajustar anchos\n        buf = WidthAdjuster.adjust_widths(buf, 8, 40)\n        \n        return buf", "core/column_reorderer.py": "import pandas as pd\nfrom io import BytesIO\n\nclass ColumnReorderer:\n    @staticmethod\n    def reorder_columns(input_buffer: BytesIO, columns: list) -> BytesIO:\n        \"\"\"\n        Reorders columns in the Excel file (in-memory) according to the provided list.\n        Columns not in the list are appended at the end in their original order.\n        Args:\n            input_buffer (BytesIO): Input Excel file in memory.\n            columns (list): Desired column order.\n        Returns:\n            BytesIO: Excel file with columns reordered.\n        \"\"\"\n        input_buffer.seek(0)\n        df = pd.read_excel(input_buffer)\n        # Columns in the provided list\n        ordered = [col for col in columns if col in df.columns]\n        # Columns not in the provided list\n        remaining = [col for col in df.columns if col not in columns]\n        new_order = ordered + remaining\n        df = df[new_order]\n        output_buffer = BytesIO()\n        df.to_excel(output_buffer, index=False)\n        output_buffer.seek(0)\n        return output_buffer\n", "core/width_adjuster.py": "from openpyxl import load_workbook\nfrom io import BytesIO\n\nclass WidthAdjuster:\n    @staticmethod\n    def adjust_widths(input_buffer: BytesIO, min_width: int = 8, max_width: int = 40) -> BytesIO:\n        \"\"\"\n        Adjusts column widths based on cell content, with min/max width constraints.\n        Args:\n            input_buffer (BytesIO): Input Excel file in memory.\n            min_width (int): Minimum column width.\n            max_width (int): Maximum column width.\n        Returns:\n            BytesIO: Excel file with adjusted column widths.\n        \"\"\"\n        input_buffer.seek(0)\n        wb = load_workbook(input_buffer)\n        ws = wb.active\n        for col in ws.columns:\n            max_length = 0\n            col_letter = col[0].column_letter\n            for cell in col:\n                try:\n                    value = str(cell.value) if cell.value is not None else ''\n                except Exception:\n                    value = ''\n                max_length = max(max_length, len(value))\n            # Add a little extra space\n            width = min(max_width, max(min_width, max_length + 2))\n            ws.column_dimensions[col_letter].width = width\n        output_buffer = BytesIO()\n        wb.save(output_buffer)\n        output_buffer.seek(0)\n        wb.close()\n        return output_buffer\n", "core/stylizer.py": "from openpyxl import load_workbook\nfrom openpyxl.styles import PatternFill, Font, Border, Side, Alignment\nfrom io import BytesIO\n\nclass Stylizer:\n    @staticmethod\n    def style_excel(input_buffer, column_configs, font_color_unused=None):\n        import openpyxl\n        wb = openpyxl.load_workbook(input_buffer)\n        ws = wb.active\n        \n        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), \n                            top=Side(style='thin'), bottom=Side(style='thin'))\n\n        for cell in ws[1]:\n            col_name = str(cell.value).strip()\n            \n            if col_name in column_configs:\n                # Extraemos ambos colores espec\u00edficos de la columna\n                bg = column_configs[col_name][\"bg_color\"]\n                txt = column_configs[col_name][\"txt_color\"]\n                \n                cell.fill = PatternFill(start_color=bg, end_color=bg, fill_type=\"solid\")\n                cell.font = Font(color=txt, bold=True, size=12)\n            \n            cell.border = thin_border\n            cell.alignment = Alignment(horizontal=\"center\", vertical=\"center\")\n\n        # Cebra (opcional: puedes usar un gris muy suave para no chocar con los colores)\n        zebra = PatternFill(start_color=\"F9F9F9\", end_color=\"F9F9F9\", fill_type=\"solid\")\n        for row in ws.iter_rows(min_row=2):\n            for cell in row:\n                cell.border = thin_border\n                if cell.row % 2 == 0:\n                    cell.fill = zebra\n\n        output = BytesIO()\n        wb.save(output)\n        output.seek(0)\n        return output\n"},
        entrypoint: "app.py",
      }, document.getElementById("root"));
    </script>
  </body>
</html>
